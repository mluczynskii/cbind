from jinja2 import Environment, FileSystemLoader
from pathlib import Path 
import json 
import argparse
import sys

TEMPLATES = Path(__file__).resolve().parent / "templates"

env = Environment(
  loader=FileSystemLoader(TEMPLATES),
  autoescape=False
)

def apply_template(name, context):
  """
  Renders a Jinja2 template with the given name using the provided context.
  :param name: Name of the template file (e.g., structs/getter.c.j2).
  :param context: Dictionary of values passed to the template.
  :return: Rendered template as a string.
  """
  template = env.get_template(name)
  return template.render(context)

def load_ast(infile):
  """
  Loads the AST description .json file into a python dictionary.
  :param infile: Handle for the .json file.
  :return: .json file as a python dictionary
  """
  try:
    ast = json.load(infile)
    return ast 
  except json.JSONDecodeError as ex:
    print(f"Invalid JSON: {ex}", file=sys.stderr)
    sys.exit(1)

def create_register_context(ast):
  """
  """
  def utility_names(typename, fieldname, getter=True):
    suffix = f"{'get' if getter else 'set'}_{fieldname}"
    return {"lua_name": suffix, "c_name": f"cbind_{typename}_{suffix}"}
  api = []
  for function in ast["Functions"]:
    name = function["Name"]
    api.append({"lua_name": name, "c_name": f"cbind_{name}"})
  registers = [{"name": "functions", "functions": api}]
  for struct in ast["Structs"]:
    typename = struct["Typename"]
    fields = [field["Name"] for field in struct["Fields"]]
    utilities = [
      utility_names(typename, field, getter=idx%2) 
      for field in fields for idx in range(2)
    ]
    constructor = [{"lua_name": "new", "c_name": f"cbind_{typename}_new"}]
    registers.extend([
      {"name": f"{typename}lib_m", "functions": utilities}, 
      {"name": f"{typename}_f", "functions": constructor}
    ])
  return registers

def create_context(ast):
  """
  Creates a context passed to the source.c.j2 template
  :param ast: The .json dump as a python directory
  :return: The context directory.
  """
  context = {
    "functions": ast["Functions"],
    "registers": create_register_context(ast),
    "submodules": [struct["Typename"] for struct in ast["Structs"]],
    "structs": ast["Structs"]
  }
  return context

def main():
  parser = argparse.ArgumentParser(description="Generate .c binding code")
  parser.add_argument(
    "file", 
    type=argparse.FileType("r"), nargs="+", 
    help=".json files generated by the AST parser"
  )
  parser.add_argument(
    "-o", "--output", 
    type=argparse.FileType("w"), 
    help="output .c file, default is 'binding.c'"
  )
  args = parser.parse_args()
  outfile = args.output or open("binding.c", "w")
  for infile in args.file:
    ast = load_ast(infile)
    template = apply_template("source.c.j2", create_context(ast))
    outfile.write(template)

if __name__ == "__main__":
  main()



