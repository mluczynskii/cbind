from jinja2 import Environment, FileSystemLoader
from pathlib import Path 
import json 
import argparse
import sys
import os

TEMPLATES = Path(__file__).resolve().parent / "templates"

def split_filter(value, sep=None):
  return value.split(sep)

env = Environment(
  loader=FileSystemLoader(TEMPLATES),
  autoescape=False
)

env.filters["split"] = split_filter

def apply_template(name, context):
  """
  Renders a Jinja2 template with the given name using the provided context.

  Args:
    name: Name of the template file (e.g., structs/getter.c.j2).
    context: Dictionary of values passed to the template.

  Returns
    template: Rendered template as a string.
  """
  template = env.get_template(name)
  return template.render(context)

def load_ast(infile):
  """
  Loads the AST description .json file into a python dictionary.

  Args:
    infile: Handle for the .json file.
  
  Returns
    ast: .json file as a python dictionary
  """
  try:
    ast = json.load(infile)
    return ast 
  except json.JSONDecodeError as ex:
    print(f"Invalid JSON: {ex}", file=sys.stderr)
    sys.exit(1)

def create_enum_context(ast):
  primitives = ["INT", "SHORT", "LONG", "FLOAT", "DOUBLE", "STRING"]
  pointer_tags = {
    "typename": "ctype",
    "fields": [{"name": primitive, "value": i} for i, primitive in enumerate(primitives)]
  }
  return ast["enums"] + [pointer_tags]

def create_register_context(ast):

  def utility_names(typename, fieldname, getter=True):
    assert(len(typename.split()) == 1)
    suffix = f"{'get' if getter else 'set'}_{fieldname}"
    return {"lua_name": suffix, "c_name": f"cbind_{typename}_{suffix}"}

  api_calls = []
  for function in ast["functions"]:
    name = function["name"]
    api_calls.append({"lua_name": name, "c_name": f"cbind_{name}"})
  api_calls.extend([
    {"lua_name": "wrap", "c_name": "cbind_wrap"},
    {"lua_name": "unwrap", "c_name": "cbind_unwrap"}
  ])
  registers = [{"register_name": "functions", "functions": api_calls}]
  for record_data in ast["records"]:
    typename = "_".join(record_data["typename"].split())
    record_fields = [field["name"] for field in record_data["fields"]]
    utilities = [
      utility_names(typename, field, getter=i % 2) 
      for field in record_fields for i in range(2)
    ]
    constructor = [{"lua_name": "new", "c_name": f"cbind_{typename}_new"}]
    registers.extend([
      {"register_name": f"{typename}_lib_m", "functions": utilities}, 
      {"register_name": f"{typename}_f", "functions": constructor}
    ])
  return registers

def cast_to_dictionary(xs):
  resulting_dictionary = {}
  for x in xs:
    typename = x["typename"]
    resulting_dictionary[typename] = x 
  return resulting_dictionary

def attach_callback_names(ast):

  def callback_name(return_data, argument_data):
    return_typename = return_data["typename"][0]
    argument_typenames = [
      argument["typename"][0] for argument in argument_data
    ] 
    return f'{return_typename}_{"".join(argument_typenames)}'

  for pointer in ast["pointers"]:
    underlying = pointer["underlying"]
    if underlying["kind"] != "function_type":
      continue 
    pointer["underlying"]["callback"] = callback_name(underlying["returns"], underlying["arguments"])

def create_callback_context(ast):
  used_callback_names = set()
  callbacks = []
  for pointer in ast["pointers"]:
    if pointer["underlying"]["kind"] != "function_type":
      continue 
    callback_name = pointer["underlying"]["callback"]
    if callback_name in used_callback_names:
      continue
    used_callback_names.add(callback_name)
    callbacks.append(pointer["underlying"])
  return callbacks

def create_context(ast):
  """
  Creates a context passed to the source.c.j2 template.

  Args:
    ast: The .json dump as a python directory.

  Returns
    context: The context directory passed to the main jinja template.
  """
  attach_callback_names(ast)
  context = {
    "functions": ast["functions"],
    "records": cast_to_dictionary(ast["records"]),
    "pointers": cast_to_dictionary(ast["pointers"]),
    "callbacks": create_callback_context(ast),
    "registers": create_register_context(ast),
    "enums": create_enum_context(ast),
    "submodules": [record["typename"] for record in ast["records"]]
  }
  return context

def main():
  parser = argparse.ArgumentParser(description="Generate .c binding code")
  parser.add_argument(
    "file", 
    type=argparse.FileType("r"), nargs="+", 
    help=".json files generated by the AST parser"
  )
  parser.add_argument(
    "-o", "--output", 
    type=str, 
    help="output .c filename, default is 'binding.c'"
  )
  parser.add_argument(
    "--header",
    type=str,
    help="output .h filename, default is same as the one in -o but with changed extension"
  )
  parser.add_argument(
    "-f", "--filter",
    type=argparse.FileType("r"), 
    help="File containing newline separated function names that we want to create a binding for, by default grabs everything present in the ast dump"
  )

  args = parser.parse_args()
  c_file = "binding.c"
  if args.output:
    c_file = args.output
  base, _ = os.path.splitext(c_file)
  h_file = base + ".h"
  if args.header:
    h_file = args.header

  for infile in args.file:
    ast = load_ast(infile)
    template = apply_template("source.c.j2", create_context(ast))
    with open(c_file, "w") as outfile:
      outfile.write(template)
  with open(h_file, "w") as header:
    template = apply_template("header.c.j2", {})
    header.write(template)

if __name__ == "__main__":
  main()



