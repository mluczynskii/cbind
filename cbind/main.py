from jinja2 import Environment, FileSystemLoader
from pathlib import Path 
import json 
import argparse
import sys

TEMPLATES = Path(__file__).resolve().parent / "templates"

env = Environment(
  loader=FileSystemLoader(TEMPLATES),
  autoescape=False
)

def apply_template(name, context):
  """
  Renders a Jinja2 template with the given name using the provided context.

  Args:
    name: Name of the template file (e.g., structs/getter.c.j2).
    context: Dictionary of values passed to the template.

  Returns
    template: Rendered template as a string.
  """
  template = env.get_template(name)
  return template.render(context)

def load_ast(infile):
  """
  Loads the AST description .json file into a python dictionary.

  Args:
    infile: Handle for the .json file.
  
  Returns
    ast: .json file as a python dictionary
  """
  try:
    ast = json.load(infile)
    return ast 
  except json.JSONDecodeError as ex:
    print(f"Invalid JSON: {ex}", file=sys.stderr)
    sys.exit(1)

def create_register_context(ast):
  """
  """
  def utility_names(typename, fieldname, getter=True):
    suffix = f"{'get' if getter else 'set'}_{fieldname}"
    return {"lua_name": suffix, "c_name": f"cbind_{typename}_{suffix}"}
  api = []
  for function in ast["Functions"]:
    name = function["Name"]
    api.append({"lua_name": name, "c_name": f"cbind_{name}"})
  registers = [{"name": "functions", "functions": api}]
  for struct in ast["Structs"]:
    typename = struct["Typename"]
    fields = [field["Name"] for field in struct["Fields"]]
    utilities = [
      utility_names(typename, field, getter=idx%2) 
      for field in fields for idx in range(2)
    ]
    constructor = [{"lua_name": "new", "c_name": f"cbind_{typename}_new"}]
    registers.extend([
      {"name": f"{typename}lib_m", "functions": utilities}, 
      {"name": f"{typename}_f", "functions": constructor}
    ])
  return registers

def attach_callback_name(ast):
  """
  Adds the generated callback name to each function pointer description inside the AST dump.

  Args:
    ast: The .json dump as a python directory
  """
  def callback_name(data):
    returns = data["Returns"]["Typename"][0]
    args = [arg["Typename"][0] for arg in data["Arguments"]]
    return f"{''.join(args)}_{returns}"

  for function in ast["Functions"]:
    for argument in function["Arguments"]:
      if argument["Kind"] == "pointer_type" and argument["Pointer"]["Kind"] == "function_type":
        name = callback_name(argument["Pointer"])
        argument["Pointer"]["Template"] = name 

def needed_callbacks(ast):
  """
  Creates a list of function pointer descriptions that need their helper functions.

  Args:
    ast: The .json dump as a python directory
  
  Raises:
    ValueError: The ast hasn't been passed through attach_callback_name first.
  
  Returns:
    result: A list of function pointer descriptions
  """
  result = {}
  for function in ast["Functions"]:
    for argument in function["Arguments"]:
      if argument["Kind"] == "pointer_type" and argument["Pointer"]["Kind"] == "function_type":
        if not argument["Pointer"]["Template"]:
          raise ValueError("Need to call attach_callback_name(ast) first")
        name = argument["Pointer"]["Template"]
        result[name] = argument["Pointer"]
  return list(result.values())

def create_context(ast):
  """
  Creates a context passed to the source.c.j2 template.

  Args:
    ast: The .json dump as a python directory.

  Returns
    context: The context directory passed to the main jinja template.
  """
  attach_callback_name(ast)
  context = {
    "functions": ast["Functions"],
    "registers": create_register_context(ast),
    "submodules": [struct["Typename"] for struct in ast["Structs"]],
    "structs": ast["Structs"],
    "callbacks": needed_callbacks(ast)
  }
  return context

def main():
  parser = argparse.ArgumentParser(description="Generate .c binding code")
  parser.add_argument(
    "file", 
    type=argparse.FileType("r"), nargs="+", 
    help=".json files generated by the AST parser"
  )
  parser.add_argument(
    "-o", "--output", 
    type=argparse.FileType("w"), 
    help="output .c file, default is 'binding.c'"
  )
  args = parser.parse_args()
  outfile = args.output or open("binding.c", "w")
  for infile in args.file:
    ast = load_ast(infile)
    template = apply_template("source.c.j2", create_context(ast))
    outfile.write(template)

if __name__ == "__main__":
  main()



