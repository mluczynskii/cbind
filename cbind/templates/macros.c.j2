{#
  Template: macros.c.j2
  Description: A collection of macros used throughout other templates, mainly for 
    moving around data from/to the lua_State* stack. Should be imported using 
    "import _ with context".
  Author: Mateusz Łuczyński
  Email: mateusz.luczynski02@gmail.com
#}

{# 
  Macro: macros.unsafe_fetch()
  Description: Renders a piece of code for popping a value from the stack 
    WITHOUT invalid type checks. This is used in the closure templates where we 
    cannot invoke luaL_error(). 
#}
{% macro unsafe_fetch(state, stack_idx, variable_name, type) -%}
{%- set typename = type["typename"] -%}
{#-     -#}
{% if type["kind"] in ["record_type", "union_type"] or (type["kind"] == "pointer_type" and pointers[typename]["underlying"]["kind"] in ["record_type", "union_type"]) -%}
{{ typename ~ " *" ~ variable_name }} = ({{ typename }} *)lua_touserdata({{ state }}, {{ stack_idx }});
{#-     -#}
{%- elif type["kind"] == "character_type" -%}
{{ typename ~ " " ~ variable_name }} = lua_tostring({{ state }}, {{ stack_idx }})[0];
{#-     -#}
{%- elif type["kind"] == "integer_type" or type["kind"] == "enumeral_type" -%}
{{ typename ~ " " ~ variable_name }} = lua_tointeger({{ state }}, {{ stack_idx }});
{#-     -#}
{%- elif type["kind"] == "real_type" -%}
{{ typename ~ " " ~ variable_name }} = lua_tonumber({{ state }}, {{ stack_idx }});
{#-     -#}
{%- elif type["kind"] == "pointer_type" and pointers[typename]["underlying"]["kind"] == "function_type" -%}
lua_pushvalue({{ state }}, {{ stack_idx }});
closure_t *data_{{ stack_idx }} = (closure_t *)malloc(sizeof(closure_t));
data_{{ stack_idx }}->L = (void *){{ state }};
data_{{ stack_idx }}->key = luaL_ref({{ state }}, LUA_REGISTRYINDEX);
void *{{ variable_name }} = alloc_callback({{ pointers[typename]["underlying"]["callback"] }}, (void *)data_{{ stack_idx }});
closure_data = insert_node(closure_data, data_{{ stack_idx }}->key, (void*){{ state }}, {{ variable_name }});
{#-     -#}
{%- elif type["kind"] == "pointer_type" -%}
{{ typename ~ " " ~ variable_name }} = ({{ typename }})lua_touserdata({{ state }}, {{ stack_idx }});
{#-     -#}
{%- else -%}
#error "Unhandled variable type"
{%- endif %}
{#-     -#}
{%- endmacro %}

{# 
  Macro: macros.safe_fetch()
  Description: Renders a piece of code for popping a value from the stack 
    WITH invalid type checks. Any errors are reported using luaL_error(). 
#}
{% macro safe_fetch(state, stack_idx, variable_name, type) -%}
{%- set typename = type["typename"] -%}
{#-     -#}
{% if type["kind"] in ["record_type", "union_type"] -%}
{{ typename ~ " *" ~ variable_name }} = ({{ typename }} *)luaL_checkudata({{ state }}, {{ stack_idx }}, "{{ typename }}"); 
{#-     -#}
{%- elif type["kind"] == "character_type" -%}
{{ typename ~ " " ~ variable_name }};
if (lua_isstring({{ state }}, {{ stack_idx }}))
  {{ variable_name }} = lua_tostring({{ state }}, {{ stack_idx }})[0];
else 
  return luaL_error({{ state }}, "Expected character at position %d", {{ stack_idx }});
{#-     -#}
{%- elif type["kind"] == "integer_type" or type["kind"] == "enumeral_type" -%}
{{ typename ~ " " ~ variable_name }};
if (lua_isinteger({{ state }}, {{ stack_idx }}))
  {{ variable_name }} = lua_tointeger({{ state }}, {{ stack_idx }});
else 
  return luaL_error({{ state }}, "Expected integer at position %d", {{ stack_idx }});
{#-     -#}
{%- elif type["kind"] == "real_type" -%}
{{ typename ~ " " ~ variable_name }};
if (lua_isnumber({{ state }}, {{ stack_idx }}))
{{ variable_name }} = lua_tonumber({{ state }}, {{ stack_idx }});
else 
  return luaL_error({{ state }}, "Expected real number at position %d", {{ stack_idx }});
{#-     -#}
{%- elif type["kind"] == "pointer_type" and pointers[typename]["underlying"]["kind"] == "function_type" -%}
if (!lua_isfunction({{ state }}, {{ stack_idx }}))
  return luaL_error({{ state }}, "Expected a function at position %d", {{ stack_idx }});
{{ unsafe_fetch(state, stack_idx, variable_name, type) }}
{#-     -#}
{%- elif type["kind"] == "pointer_type" -%}
{{ typename ~ " " ~ variable_name }} = ({{ typename }})lua_touserdata({{ state }}, {{ stack_idx }});
{#-     -#}
{%- else -%}
#error "Unhandled variable type"
{%- endif %}
{#-     -#}
{%- endmacro %}

{# 
  Macro: macros.safe_fetch()
  Description: Renders a piece of code for passing a variable into the API call.
    This includes necessary type casting for closures and dereferencing for records passed
    by-value. 
#}
{% macro pass(variable_name, type) -%}
{%- set typename = type["typename"] -%}
{#-     -#}
{% if type["kind"] in ["record_type", "union_type"] -%}
*({{ variable_name }})
{#-     -#}
{%- elif type["kind"] == "pointer_type" and pointers[typename]["underlying"]["kind"] == "function_type" -%}
({{ typename }})({{ variable_name }})
{#-     -#}
{%- else -%}
{{ variable_name }}
{%- endif %}
{#-     -#}
{%- endmacro %}

{# 
  Macro: macros.push()
  Description: Renders a piece of code for pushing a value to the stack. 
#}
{% macro push(state, variable_name, type) -%}
{#-     -#}
{% if type["kind"] == "integer_type" or type["kind"] == "enumeral_type" -%}
lua_pushinteger({{ state }}, {{ variable_name }});
{#-     -#}
{%- elif type["kind"] == "character_type" -%}
(void)lua_pushlstring({{ state }}, &({{ variable_name }}), 1);
{#-     -#}
{%- elif type["kind"] == "real_type" -%}
lua_pushnumber({{ state }}, {{ variable_name }});
{#-     -#}
{%- elif type["kind"] == "record_type" -%}
{%- set typename = type["typename"] -%}
{{ typename }} *temp_push = ({{ typename }} *)lua_newuserdata({{ state }}, sizeof({{ typename }}));
{%- for field in records[typename]["fields"] %}
temp_push->{{ field["name"] }} = {{ variable_name ~ "." ~ field["name"] }};
{%- endfor %}
luaL_getmetatable({{ state }}, "{{ typename }}");
lua_setmetatable({{ state }}, -2);
{#-      -#}
{%- elif type["kind"] == "pointer_type" -%}
lua_pushlightuserdata({{ state }}, (void *){{ variable_name }});
{#-      -#}
{%- else -%}
#error "Unhandled variable type"
{%- endif -%}
{#-     -#}
{%- endmacro %}