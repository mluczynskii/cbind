\documentclass[polish, english]{iithesis}

\englishtitle{Fully automatic Lua binding for C\fmlinebreak{} based on compiler AST}
\polishtitle{Automatyczne generowanie bindingu z języka C do Lua na podstawie drzewa AST}

\author{Mateusz Łuczyński}
\advisor{dr Piotr Witkowski}

\polishabstract{
  Lua to niedużych rozmiarów, szybki i przenośny język skryptowy.
  Te cechy sprawiają, że dużo aplikacji jest kompilowane razem z jego interpreterem, co pozwala deweloperom na modyfikacje funkcjonalności bez konieczności przebudowywania głównego kodu źródłowego.
  W dużych projektach prowadzi to do istotnej oszczędności czasu spędzonego na rekompilacji, podczas której aplikacja może nie być zdatna do użytku.
  Dobrze udokumentowane API oraz bliskie powiązanie Lua z językiem C, powoduje że projekty napisane w C/C++ idealnie nadają się do wykorzystania wspomnianego podejścia.
  Przykładami mogą być popularne gry wideo takie jak \textit{World of Warcraft}, czy \textit{Roblox}, w których możliwość rozwoju gry przez jej fanów jest ich sporą częścią i w dużej mierze przyczyniło się do ich sukcesu.
  W mojej pracy podjąłem się zaimplementowania narzędzia służącego do automatycznego generowania kodu w C, potrzebnego do uruchamiania skryptów w Lua, które korzystają z napisanych w C wywołań bibliotecznych będących częścią aplikacji.
  W ten sposób, mając kod źródłowy zawierający implementacje API, można bez dodatkowej pracy dodać możliwość dynamicznego rozbudowywania do swojego projektu.
}
\englishabstract{
  Lua is a light-weight, fast and portable scripting language. 
  Because of it, many applications choose to embed it's interpreter inside them, allowing the developers to extend their work without the need of rebuilding the core source code.
  In large projects this can save a lot of time spent on recompilation, during which the application can be rendered unusable.
  A well written official API and Lua's close connection to the C language, make C/C++ applications a perfect subject for the aforementioned process.
  We can see some examples of it in popular video games, like \textit{World of Warcraft} or \textit{Roblox}, where the ability for the dedicated fanbase to extend their favorite game takes a huge role in the projects success.
  In my work, I implemented a tool for automatically generating C code required for running Lua scripts, which can call API functions (written in C) that are part of the application.
  That way, given the source code containing the API calls definitions, we can add the extension capabilities to the project with little to none extra work. 
}

\date{\today}
\transcriptnum{331826}
\advisorgen{dr. Piotra Witkowskiego}

\begin{document}

\chapter{Introduction}
Embedding Lua into applications is a common practice among many projects which support dynamic expansion or configuration of some of it's components.
The language itself is extremely simple (only twenty keywords) but powerful at the same time, the official website claiming it to be the leading scripting language in the video game industry.

This thesis will focus on integrating Lua into projects written in C, specifically on exposing API calls to Lua scripts and running such scripts from within the main application.
To do so, we need to write appropriate wrappers (we will call a collection of those wrappers the \textit{binding} code) for each exposed API function, based on it's signature.
Fortunately, everything needed can be found within the \textit{Abstract Syntax Tree} generated by the compiler. 

The project consists of two main parts: the AST parser and the binding generator.
Both are written in pure Python, with the parser producing an intermediate JSON file.
Further analysis will be based on the GCC compiler, but with the parser being an isolated component, there is a possibility of writing an auxillary one for a different tool.

  \section{Project background}
The project originated as part of \textit{Innovative projects by Nokia} initiative, where it was limit-tested and prototyped by a team of three students (including me).
I was responsible for the code generation part of it, with my teammates developing unit tests and the AST parser. 
As part of this thesis, and with appropriate acknowledgement from my team, I rewrote and heavily expanded the code base, focusing on taking it out of the prototype form and turning it into a complete project.
  \section{Motivation}
During the prototyping phase we focused on realizing a concrete scenario: 
let's say we have an application (which we will call the \textit{scheduler}) that stores callbacks sent to it, and calls them when an appropriate event occurs.
The main part of the \textit{scheduler's} interface is the \textit{register} function, that accepts a pointer to a function.
Now, we would like to be able to pass callbacks written in Lua to the \textit{register} function, and be able to call them even long after the script has finished registering them. 
That way, the \textit{scheduler's} reactions for different events can be easily swapped and modified. 
At the same time, we would like the Lua components to be able to use functionality available to standard callbacks passed from within the application code, like a series of curated API calls using even user-defined C data structures.
\chapter{Lua C API overview}
  \section{Core concepts}
  \section{Calling C functions from Lua scripts}
  \section{Obstacles and limitations}
\chapter{AST generated by the compiler}
  \section{Example overview based on the \textit{gcc} compiler}
\chapter{Parsing the AST}
  \section{Goal and the output format}
  \section{Function arguments and their types}
  \section{Handling user defined data structures}
  \section{Function pointers}
\chapter{Generating the binding code}
  \section{Fetching the arguments}
    \subsection{Simple types}
    \subsection{C structs and unions}
    \subsection{Callbacks and closures}
  \section{Error handling}
  \section{Exposing the interface}
\chapter{Example usage}
\chapter{Conclusion}
  \section{Possible further development}

\end{document}