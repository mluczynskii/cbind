\documentclass[polish, english]{iithesis}
\usepackage{listings}
\usepackage{csquotes}

\lstdefinelanguage{json}{
  basicstyle=\normalfont\ttfamily,
  numbers=left,
  stepnumber=1,
  numbersep=8pt,
  showstringspaces=false,
}

\englishtitle{Fully automatic Lua binding for C\fmlinebreak{} based on compiler AST}
\polishtitle{Automatyczne generowanie bindingu z języka C do Lua na podstawie drzewa AST}

\author{Mateusz Łuczyński}
\advisor{dr Piotr Witkowski}

\polishabstract{
  Lua to niedużych rozmiarów, szybki i przenośny język skryptowy.
  Te cechy sprawiają, że dużo aplikacji jest kompilowane razem z jego interpreterem, co pozwala deweloperom na modyfikacje funkcjonalności bez konieczności przebudowywania głównego kodu źródłowego.
  W dużych projektach prowadzi to do istotnej oszczędności czasu spędzonego na rekompilacji, podczas której aplikacja może nie być zdatna do użytku.
  Dobrze udokumentowane API oraz bliskie powiązanie Lua z językiem C, powoduje że projekty napisane w C/C++ idealnie nadają się do wykorzystania wspomnianego podejścia.
  Przykładami mogą być popularne gry wideo takie jak \textit{World of Warcraft}, czy \textit{Roblox}, w których możliwość rozwoju gry przez jej fanów jest ich sporą częścią i w dużej mierze przyczyniło się do ich sukcesu.
  W mojej pracy podjąłem się zaimplementowania narzędzia służącego do automatycznego generowania kodu w C, potrzebnego do uruchamiania skryptów w Lua, które korzystają z napisanych w C wywołań bibliotecznych będących częścią aplikacji.
  W ten sposób, mając kod źródłowy zawierający implementacje API, można bez dodatkowej pracy dodać możliwość dynamicznego rozbudowywania do swojego projektu.
}
\englishabstract{
  Lua is a light-weight, fast and portable scripting language. 
  Because of it, many applications choose to embed it's interpreter inside them, allowing the developers to extend their work without the need of rebuilding the core source code.
  In large projects this can save a lot of time spent on recompilation, during which the application can be rendered unusable.
  A well written official API and Lua's close connection to the C language, make C/C++ applications a perfect subject for the aforementioned process.
  We can see some examples of it in popular video games, like \textit{World of Warcraft} or \textit{Roblox}, where the ability for the dedicated fanbase to extend their favorite game takes a huge role in the projects success.
  In my work, I implemented a tool for automatically generating C code required for running Lua scripts, which can call API functions (written in C) that are part of the application.
  That way, given the source code containing the API calls definitions, we can add the extension capabilities to the project with little to none extra work. 
}

\date{\today}
\transcriptnum{331826}
\advisorgen{dr. Piotra Witkowskiego}

\begin{document}

\chapter{Introduction}
Embedding Lua into applications is a common practice among many projects which support dynamic expansion or configuration of some of it's components.
The language itself is extremely simple (only twenty keywords) but powerful at the same time, the official website claiming it to be the leading scripting language in the video game industry.

This thesis will focus on integrating Lua into projects written in C, specifically on exposing API calls to Lua scripts and running such scripts from within the main application.
To do so, we need to write appropriate wrappers (we will call a collection of those wrappers the \textit{binding} code) for each exposed API function, based on it's signature.
Fortunately, everything needed can be found within the \textit{Abstract Syntax Tree} generated by the compiler. 

The project consists of two main parts: the AST parser and the binding generator.
Both are written in pure Python, with the parser producing an intermediate JSON file.
Further analysis will be based on the GCC compiler, but with the parser being an isolated component, there is a possibility of writing an auxillary one for a different tool.

  \section{Project background}
The project originated as part of \textit{Innovative projects by Nokia} initiative, where it was limit-tested and prototyped by a team of three students (including me).
I was responsible for the code generation part of it, with my teammates developing unit tests and the AST parser. 
As part of this thesis, and with appropriate acknowledgement from my team, I rewrote and heavily expanded the code base, focusing on taking it out of the prototype form and turning it into a complete project.
  \section{Motivation}
During the prototyping phase we focused on realizing a concrete scenario: 
let's say we have an application (which we will call the \textit{scheduler}) that stores callbacks sent to it, and calls them when an appropriate event occurs.
The main part of the \textit{scheduler's} interface is the \textit{register} function, that accepts a pointer to a function.
Now, we would like to be able to pass callbacks written in Lua to the \textit{register} function, and be able to call them even long after the script has finished registering them. 
That way, the \textit{scheduler's} reactions for different events can be easily swapped and modified. 
At the same time, we would like the Lua components to be able to use functionality available to standard callbacks passed from within the application code, like a series of curated API calls that can even use user-defined C data structures.
\chapter{Lua C API overview}
  The 4th edition of the \textit{Programming in Lua} book says:
  \begin{displaycquote}{pil4}
    Lua is an \textit{embedded language}. 
    This means that Lua is not a stand-alone application, but a library that we can link with other applications to incorporate Lua facilities into them.

    [\ldots] This ability to be used as a library to extend an application is what makes Lua an \textit{embeddable} language. 
    At the same time, a program that uses Lua can register new functions in the Lua environment; such functions are implemented in C (or another language), so that they can add facilities that cannot be written directly in Lua. 
    This is what makes Lua an \textit{extensible} language. 
  \end{displaycquote}
  Both approaches utilize the so-called \textit{C API} to communicate with Lua.
  To understand how we can use this API to achieve our goal, we first need to take a look at its possibilities.
  \section{Core concepts}
    At its core, the C API is just a collection of functions, constants and types that allow C programs to interact with the Lua interpreter.
    This includes, among other things, running pieces of Lua code and accessing Lua global variables.
    The main component that allows this type of communication is called the virtual \textit{stack}.
    From Lua perspective, the stack behaves as we would expect a stack to work --- that is the elements are added and removed only from the top of it.
    From the C perspective however, the `stack' is more than a traditional LIFO data structure, as random access is possible. 
    Almost every API call operates on values present on the stack, and all data is exchanged through it (from C to Lua and the other way around).  
    Each slot on the stack can hold any Lua value.
    When we want to get some value from Lua, we can ask for it and receive it on the stack.
    In a similiar manner, when we want to pass something to Lua, we first have to push it onto the stack.
    There is a collection of calls doing the pushing and popping operations, defined for different C types.
    The responsibility of using the correct ones falls on the C programmer.
    The API also provides a way of manipulating the stack in more \textit{unusual} ways, like replacing or inserting elements in arbitrary places and even element rotation similiar to the one performed bit-wise by assembly instructions like \texttt{ROR} or \texttt{ROL}.
    It is also worth noting that the stack is \emph{not} a global structure --- each separate interaction (that is for example, a foreign function call) gets its own, local stack.

    The stack approach prevents the combinatorial explosion of the API calls (one for each type combination), and also removes any concern about garbage collection --- the Lua runtime has exact knowledge about the use of variables stored on the stack and so it will not accidentaly collect them.
    It also lets us deal with the mismatch between the type systems (dynamic in Lua and static in C).
    The only price to pay is the need to manually check the correctness of every operation, and having to deal with non-descriptive memory errors when something goes wrong, with the latter being especially common without exerting special care.
  \section{Calling C functions from Lua scripts}\label{call_c_from_lua}
    For Lua script to be able to call a function written in C, the function must follow a very simple protocol.
    Let's look at an example provided in \textit{Programming in Lua}\cite{pil4}:
    \begin{lstlisting}[caption=Example C function to be called from Lua, language=C]
      static int l_sin (lua_State *L) {
        double d = lua_tonumber(L, 1); /* get argument */
        lua_pushnumber(L, sin(d)); /* push result */
        return 1; /* number of results */
      }
    \end{lstlisting}
    Every eligible function has to have the same prototype --- it has to return an int and accept an argument of type \lstinline[language=C]|lua_State*|.
    The single argument is in fact the stack described previously.
    As we can see, the body of the function consists of:
    \begin{enumerate}
      \item Fetching the passed arguments. 
        This step is more complicated for more complex types, but here we only need a single real number \textit{d}.
        Each argument, when passed from Lua, gets its unique index on the stack (starting from one and counting up).
        When fetching the argument we need to specify the correct index.
        In the provided example, type checking and error handling is omitted.
      \item Pushing the result back on the stack.
        Since we are implementing a simple sine function here, we simply apply it to the argument and push it on top of the stack.
      \item Returning the number of `returned' values.
        This way the Lua runtime will know how many values it needs to take from the top of the stack (here --- only one).
        After that, the rest of the stack is cleared and the script execution is resumed.
    \end{enumerate}
    Before we can do anything with this function though, we need to register it.
    In order to do that, we can mimic the behavior of Lua modules and create our own from within the C code.
    In order to do that, we have to declare an array describing the module somewhere in our code.
    \begin{lstlisting}[language=C, caption=Module declaration]
      static const struct luaL_Reg mylib [] = {
        {"sin", l_sin},
        {NULL, NULL} /* sentinel */
      };
    \end{lstlisting}
    We now have two ways of continuing.
    We can either link our module dynamically, that is by compiling it into a shared library (\texttt{.so}, \texttt{.dll}) and including it in a Lua script using the keyword \texttt{require}, or register the function as a global Lua variable using a combination of \texttt{lua\_pushfunction} and \texttt{lua\_setglobal} API calls. 
    The second approach assumes that we will run the Lua interpreter from within the C program that registers the function.
    The first approach requires putting an additional function into our source code:
    \begin{lstlisting}[language=C, caption=The \texttt{luaopen\_mylib} function]
      int luaopen_mylib (lua_State *L) {
        luaL_newlib(L, mylib);
        return 1;
      }
    \end{lstlisting}
    This function gets automatically called after including the module with \texttt{require}.
    No matter the approach, we can then call our function from within a Lua script by calling \texttt{mylib.sin}.
  \section{Some obstacles and limitations}
    Even though the API makes exchanging data pretty straightforward, there are still some considerations we need to take into account.
    First of all, we already mentioned how the type system differs between Lua and C.
    More specifically, let's look at how we can implement some more complex data structures in both worlds.

    In C, we would typically create a \texttt{struct} or an \texttt{union} to represent a data structure.
    Then, we could introduce a series of functions doing operations on instances of such data types.
    In Lua however, we do not have a strict equivalent of C \texttt{structs}.
    The main way of achieving something similiar is done through the use of Lua's associative tables.
    This is not what we want though --- we want to use actual instances of our API's \texttt{structs}, not their cheap knockoffs.
    The solution is creating default constructors for each introduced data type, along with some utility functions (\textit{setters} and \textit{getters}).
    This is done through a special API data type called \textit{userdata} and is explained in more detail later.
    This way we can create \texttt{structs} and manipulate them from within Lua.

    Another problem is related to passing callbacks from Lua to C.
    In Lua, functions are \textit{first class citizens} and we can pass them as arguments to other functions, including those introduced by our binding code.
    For C functions, that is not the case, even though we have something very similiar --- function pointers.
    Our problem is figuring out a way to pass a C function pointer to an API function, that when dereferenced and called executes the function passed on the stack from within a Lua script.
    This is essentialy a problem of converting a `reference' to a Lua function to a C function pointer, which turns out is not trivial and is a source of inconvenience and several complications. 

\chapter{AST generated by the compiler}
The GCC compiler provides a set of options that allow developers to inspect different parts of the compilation process.
Among these options are some that produce debug dumps from various points in the compilation, print some statistics like memory usage and execution time and list specific information about the compiler configuration (such as where it looks for libraries).
Our main interest lays within those that allow to look into the process of creating the \textit{Abstract Syntax Tree}.
The one chosen for the project is called \texttt{-fdump-tree-original-raw} --- it tells GCC to produce a file containing the intermediate language tree from the \textit{original} pass, in it's \textit{raw} form (unlike the default, C-like representation). 
The produced dump is in an easily parsable format and contains every information we need:
\begin{itemize}
  \item API function signatures --- name, return type and argument types,
  \item For user defined data structures --- their names and fields they contain (also, their \textit{order} within the struct),
  \item For function pointers --- essentialy the same information we need about the API functions.
\end{itemize}
To know how we can extract this information we first inspect the tree representation in more detail.
  \section{General structure}
The whole AST dump consists of \textit{chunks} (designated by a line beginning with \texttt{;; Function}, followed by the relevant function name), which in turn consist of a series of \textit{nodes}.
Each node begins with an at sign (@) and an unique index number (along with a type of the node), and contains several key-value pairs, where each value either links to another node or represents some kind of property of the current one.
Even though the format is fairly simple, the documentation is non-existent or really hard to find --- fortunately a set of experiments allows us to learn more about each node and its relation to our task. 

For now let's assume we are working with a single function called \texttt{foo}, which takes an \texttt{int} as an argument and returns one as well.
After invoking the compiler with the previously mentioned option, we should get a dump file containing a single chunk of nodes.
The number of nodes will obviously depend on the implementation of \texttt{foo}, but some of them will always exist and they are are the most useful ones.
Our main interest will be focused on the \texttt{function\_decl} node --- its a central part of every node related to the API call signature.
\begin{lstlisting}[caption=Example \texttt{function\_decl} node]
  @14  function_decl  name: @20  type: @21  srcp: api.c:5      
                      args: @15  link: extern
\end{lstlisting}
From this node we can branch out in different directions: follow the node chain starting with \texttt{name} to get the function name, get information about the return type from the \texttt{type} node and inspect funtion arguments using the \texttt{args} node.
Other nodes that we should pay attention to are \texttt{parm\_decl} for function arguments, \texttt{field\_decl} for struct definitions and various nodes ending with \texttt{\_type} --- these and more will be covered in more detail in the relevant sections.
  \section{Function arguments and their types}
Following our \texttt{foo} example, let's first look at the way to extract function arguments.
As mentioned before, we can follow the \texttt{args} property of the \texttt{function\_decl} node to gather information about function arguments.
This will show that they are stored in nodes of type \texttt{parm\_decl}.
\begin{lstlisting}[caption=Example \texttt{parm\_decl} node]
  @15  parm_decl  name: @21  type: @22  scpe: @14     
                  srcp: api.c:4  argt: @22     
                  size: @11  algn: 8  used: 1
\end{lstlisting}
As we can see from the example, the node conveniently points to everything we need --- mainly the type, but the name is also there.
There's one problem however --- there seems to be no way of getting more than one argument this way.
More specifically, there is no property linking to the rest of the arguments. 
We could try finding every node marked as \texttt{parm\_decl} listed in currently processed chunk, but this creates another, more serious problem --- we have no way of determining the correct order of arguments.
This is especially crucial because without establishing the order we have no way of calling the API later, during the generation of the binding code.

The solution is not too far off though.
Looking at the node pointed to by the \texttt{type} property of the \texttt{function\_decl} node, followed by the \texttt{prms} property of the resulting node we end up with yet another node type: \texttt{tree\_list}.
\begin{lstlisting}[caption=Example \texttt{tree\_list} node]
  @28  tree_list  valu: @22 chan: @30
\end{lstlisting}
This is by far the simplest one, containing only two properties. 
It turns out that the \texttt{valu} property points exactly where we want to end up --- that is the \texttt{\_type} node corresponding to a function argument (described in a moment).
On the other hand, the \texttt{chan} property, if present, points to the next \texttt{tree\_list} in the chain.
This way, we can extract all argument types in the correct order.
There is a small caveat to this approach though, as we cannot easily get the name of the currently processed argument.
This is a price we can pay though, as the names in this case are purely optional and play no role in the binding code, other than cosmetic. 

Let's take a look at the \texttt{\_type} node in more detail.
\begin{lstlisting}[caption=Example \texttt{\_type} node]
  @7  integer_type  name: @10  size: @11  algn: 32      
                    prec: 32  sign: signed  min: @12     
                    max: @13
\end{lstlisting}
In this example, we are looking at a node describing an integer type.
Every integer type available in C has a link to a node like this (\texttt{int}, \texttt{long}, \texttt{short} but also \texttt{char}).
We can determine the specific type from the \texttt{name} property.
In order to do so, we have to go through a \texttt{type\_decl} node, which also lets us determine if the relevant type was declared using the \texttt{typedef} directive (through the presence of \texttt{unql} property).
Since the Lua C API handles character types differently than numbers, the \texttt{size} property is also worth checking --- if it points to a constant equal to one byte, then we know that we are working with a \texttt{char}.
Other \texttt{\_type} nodes that are commonly present include \texttt{real\_type} for floating point numbers (\texttt{float} or \texttt{double}), \texttt{pointer\_type}, for pointers (including function pointers) and \texttt{record\_type} for user-defined data structures.
  \section{Handling user defined data structures}
As already mentioned, if we stumble upon a \texttt{record\_type} declaration somewhere inside a chunk, then we know that the function uses a \texttt{struct} inside it's body.
Further down the line, we will be creating an interface for each structure that is used as an argument or return value from the API calls.
Because of this, we need to know the contents of every such data type.
Assume that we have a declaration representing a pair in our code:
\begin{lstlisting}[language=C, caption=Example \texttt{struct} declaration]
  typedef struct {
    int a, b;
  } pair_t;
\end{lstlisting}
In this example we declared \texttt{pair\_t} as a \texttt{typedef} to showcase an important property of the language tree.
Now, if the function \texttt{foo} uses \texttt{pair\_t} as one of its arguments, we should be able to see the following nodes inside the AST dump:
\begin{lstlisting}[caption=Example \texttt{record\_type} nodes for the \texttt{pair\_t} type]
  @22  record_type  name: @29  unql: @23  size: @11     
                    algn: 8  tag: struct  flds: @16
  @23  record_type  size: @11  algn: 8  tag: struct  
                    flds: @16
\end{lstlisting}
The \texttt{record\_type} that we will see by following the \texttt{tree\_list} method described previously, will be the first one listed.
Because the \texttt{unql} property is present, we can deduce that the struct is in fact declared using a \texttt{typedef}.
Furthermore, we can access the type name (\texttt{pair\_t}) by following the \texttt{name} node chain.
We can also see that there is a property called \texttt{flds} --- it shouldn't be a surprise that it links to nodes related to the struct fields.
Like with function arguments however, we encounter the same obstacle:
\begin{lstlisting}[caption=Example \texttt{field\_decl} node]
  @16  field_decl name: @21  type: @7  scpe: @23     
                  srcp: api.h:9  size: @11     
                  algn: 8  bpos: @24
\end{lstlisting}
We have access only to the first of the two fields of the \texttt{pair\_t} structure.
This time though, we can gather each \texttt{field\_decl} declaration present in the processed chunk, and connect it with its corresponding data type.
The provided \texttt{field\_decl} example is actually taken from the very same dump file as the example \texttt{record\_type} nodes.
We can see that through the \texttt{scpe} property, we can link back to the correct \texttt{record\_type} declaration (notice the matching index number).
There's just a little catch --- we can see that the \texttt{record\_type} that we get in this way is not the same that we access trough the \texttt{tree\_list} traversal.
This is because we declared \texttt{pair\_t} as a typedef --- without it the process is simplified and we can access the type name straight away.
In this case however we need to put extra effort to match these two \texttt{record\_type} declarations together (using the \texttt{unql} property value).
After determining the ownership of the processed field, we can access its name and type like previously with function arguments.
  \section{Function pointers}
Function pointers introduce us to yet another kind of a \texttt{type} node: the \texttt{pointer\_type} node.
Its use is not reserved exclusively for them though; as the name suggests it will be present whenever the source code uses a pointer type.
By looking underneath the \texttt{ptd} field of this node, we get to the main source of information about the pointer, the \texttt{function\_type} node.
\begin{lstlisting}[caption=Example \texttt{pointer\_type} and \texttt{function\_type} nodes]
  @23  pointer_type  size: @24  algn: 64  ptd : @31
  @31  function_type  size: @29  algn: 8  retn: @7      
                      prms: @33
\end{lstlisting} 
Function pointers are much simpler to parse than API calls, as everything we need can be taken from the \texttt{retn} and \texttt{prms} properties.
The return type is hidden beneath the \texttt{retn} field --- its retrieval is analogous to previously described type extraction.
The \texttt{prms} property takes us straight to the \texttt{tree\_list} chain, from which we can extract the exact parameter types.
  \section{The output format}
From the beginning the idea was to separate the parser from the binding generator, to allow for some modularity when it comes to different compilers.
The only way these two components interact with each other is through an intermediate \texttt{.json} representation.
A potential developer interested in extending the tool for another kind of compilator is free to approach the AST parsing in whatever way they feel most convenient, as long as the resulting output adheres to the following structure.
First of, the top-level JSON object should contain two fields: \texttt{Functions} and \texttt{Structs}. 
The value of the first one should be a list of objects containing information about desired API calls.
Each object should respect the following convention:
\begin{lstlisting}[language=json, caption=Example API \texttt{.json} function description]
  {
    "Name": "foo",
    "Returns": {
      "Kind": "integer_type",
      "Typedef": false,
      "Typename": "int"
    },
    "Arguments": [
      {
        "Name": "var1",
        "Kind": "record_type",
        "Typedef": true,
        "Typename": "pair_t"
      }
    ]
  }
\end{lstlisting}
Each type should be described by its name, family it belongs to (complacent with the GCC way of naming them, like \texttt{integer\_type} or \texttt{character\_type}) and whether or not its declared through a typedef or not.
The last property is needed during the binding generation to satisfy the C syntax rules, mainly when working with record types (depending on the situation, adding or omitting the \texttt{struct} keyword will result in compilation errors).

The \texttt{Structs} field of the top-level object should contain information about each data structure which we want to expose to Lua scripts.
We will create a special set of utility functions for each of them --- a default constructor and a setter and getter pairs for each field.
This means that we need to include the name of the struct and type of all its components.
\begin{lstlisting}[language=json, caption=Example \texttt{Structs} array entry]
  {
    "Typename": "container",
    "Typedef": true,
    "Fields": [
      {
        "Name": "c",
        "Kind": "character_type",
        "Typedef": false,
        "Typename": "char"
      }
    ]
  }
\end{lstlisting}
The structure is analogous to the previously described one with one key difference --- this time we need to make sure that we use actual field names instead of auto-generated ones. 

\chapter{Generating the binding code}
  While going over the possibilities of the Lua C API (\ref{call_c_from_lua}) we saw an example \texttt{sin} function that could be called from a \texttt{.lua} script.
  All generated wrappers will follow the same three-step formula as that example function --- prepare the arguments, pass them to the API call and push the result onto the stack.
  The regularity of this structure is actually what makes the whole process so atractive in terms of code generation.
  Our main focus will lay in figuring out how to actually prepare the arguments of various types.
  \section{Simple types}
  \section{C structs and unions}
  \section{Function pointers}
    This is by far the most interesting part in the whole process.
    First, let's break it down into smaller parts.
    On the stack, we are presented with a \textit{function} value.
    The API call expects a function pointer --- a location in memory of something that we can \textit{call}.
    Glossing over the Lua C API however, we see that a simple conversion (like with simple types) is not possible.
    This shouldn't be surprising, as functions in C are something inherently different than values (unlike in Lua, where functions are first-class citizens).
    We need to point to \textit{something} though --- something that when called will behave exactly like the supplied argument.

    To actually call the function passed from a Lua script, we can utilize the \texttt{lua\_pcall} call, from the Lua C API.
    The process is simple --- with the desired function on top of the stack, we need to push its arguments (in the correct order) and call \texttt{lua\_pcall}, passing the number of arguments supplied and the number of return values that we expect.
    Since functions in C can return only a single value (or not return anything at all), the second value will always be equal to one or zero.
    The call itself will pop the function along with its arguments and push the returned values on top of the stack.
    We can then retrieve the result just like we would with any other type discussed previously.

    We are now presented with a simple idea --- what if we created a \textit{template} function, with the desired signature that does the exact thing we just described.
    After all, we have knowledge about every function pointer kind used throughout the target API --- for each of them we could create a separate template.
    We would then have a function that we can point to, and consequently we could pass a pointer to it to the API call each time it's required.
    There's one problem though --- how would the actual function know which Lua function we want to call?
    Since we don't know how many different functions will be used by the \texttt{.lua} scripts beforehand, we can't create a dedicated template for each of them.
    This means however, that every function with the same signature will have to utilize the same template function.

    One idea would be to create some kind of a global reference, that the templates would use to fetch the desired function.
    A single reference would not be enough, as we have no control over the order or time that these functions will actually be called by the API (the \textit{event scheduler} concept presents that clearly).
    Multiple references don't solve anything as well --- we still wouldn't know which one to choose.

    A solution presents itself in the form of \textit{closures}.
    A closure is a function along with the environment required to run it.
    If we could create such closure during runtime, using the templates from the original idea and passing a reference to the Lua function inside their environment, we could achieve what we want.
    \subsection{Closures with \textit{GNU libffcall}}
  \section{Error handling}
  \section{Exposing the interface}
\chapter{Example usage}
\chapter{Conclusion}
  \section{Possible further development}

\begin{thebibliography}{42}
  \bibitem{pil4}
    Roberto Ierusalimschy,
    \emph{Programming in Lua},
    Feisty Duck Ltd,
    4th edition,
    2016.
\end{thebibliography}

\end{document}