from lib.components import *
from lua_components import *
from lib.structs import StructHandler 
from lib.callbacks import CallbackHandler
from lib.functions import FunctionHandler

import json
import argparse 
import boilerplate

HEADERS = [
    "lua.h",
    "lualib.h",
    "lauxlib.h"
]

def loadInfo(filename):
    with open(filename, 'r') as input:
        data = json.load(input)
    return data

def writeHeaders(file):
    for header in [Include(lib, True) for lib in HEADERS]:
        file.write(f'{header}\n') 
    file.write('\n')

def writeBoilerplate(file):
    file.write('// boilerplate code\n')
    file.write(boilerplate.code + '\n')

# writes wrapper into .lua binding file that is used to call API
# functions using struct pointers 
def writeLuaWrapper(luafile, module, fname, arglist, ptrname):
    seq = LuaSequence()
    seq = seq + LuaCallApi(module, fname, arglist)
    seq = seq + LuaCopyStruct('nstruct', ptrname)
    seq = seq + LuaReturn('value')
    wrapper = LuaFunction(
        f'{module}.{fname}',
        arglist,
        seq 
    )
    luafile.write(f'{wrapper}\n')

def writeContext(file):
    definition = Struct(
        'context',
        [Variable('lua_State*', 'stack'), Variable('int', 'idx')]
    )
    declaration = Variable('struct context', 'c')
    file.write(f'{definition}\n{declaration}\n\n')

def writeRegister(file):
    register = functionHandler.defineRegister()
    file.write(f'{register}\n\n')

# write extern declarations of the targeted C API, along with needed type declarations
def writeDeclarations(file):
    file.write(f'// struct declarations\n')
    structDeclarations = structHandler.declareStructs()
    file.write(f'{structDeclarations}\n\n')

    file.write(f'// function declarations\n')
    functionDeclarations = functionHandler.declareFunctions()
    file.write(f'{functionDeclarations}\n\n')

# write wrappers for needed callbacks and API functions
def writeWrappers(file):
    file.write(f'// callback wrappers\n')
    callbackCallers = callbackHandler.defineCallbacks()
    file.write(f'{callbackCallers}\n\n')

    file.write(f'// function wrappers\n')
    functionWrappers = functionHandler.defineWrappers()
    file.write(f'{functionWrappers}\n\n')

def main():
    parser = argparse.ArgumentParser(
        prog='binding-generator',
        description='Generates binding file based on C API AST dump.'
    )
    parser.add_argument('inputfile')
    parser.add_argument('outputfile')
    args = parser.parse_args()

    data = loadInfo(args.inputfile)

    global structHandler, callbackHandler, functionHandler
    structHandler = StructHandler(data)
    callbackHandler = CallbackHandler(data)
    functionHandler = FunctionHandler(data, structHandler)

    with open(args.outputfile, 'w') as output:
        output.write('// Generated by binding-generator.py \n')
        writeHeaders(output)
        writeContext(output)
        writeDeclarations(output)
        writeWrappers(output)
        writeRegister(output)
        writeBoilerplate(output)

if __name__ == '__main__':
    main()