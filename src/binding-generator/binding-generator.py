from lib.components import *
from lib.structs import StructHandler 
from lib.callbacks import CallbackHandler
from lib.functions import FunctionHandler
from lib.luaFunctions import LuaFunctionHandler

import json
import argparse 
import boilerplate

HEADERS = [
    "lua.h",
    "lualib.h",
    "lauxlib.h"
]

def loadInfo(filename):
    with open(filename, 'r') as input:
        data = json.load(input)
    return data

def writeHeaders(file):
    for header in [Include(lib, True) for lib in HEADERS]:
        file.write(f'{header}\n') 
    file.write('\n')

def writeBoilerplate(file):
    file.write('// boilerplate code\n')
    file.write(boilerplate.code + '\n')

def writeContext(file):
    definition = Struct(
        'context',
        [Variable('lua_State*', 'stack'), Variable('int', 'idx')]
    )
    declaration = Variable('struct context', 'c')
    file.write(f'{definition}\n{declaration}\n\n')

def writeRegister(file, functionHandler):
    register = functionHandler.defineRegister()
    file.write(f'{register}\n\n')

# writes wrappers into .lua binding file that is used to call API functions using struct pointers 
def writeLuaWrappers(luaFile, luaFunctionHandler):
    luaFile.write(luaFunctionHandler.defineWrappers())

# write extern declarations of the targeted C API, along with needed type declarations
def writeDeclarations(file, structHandler, functionHandler):
    file.write(f'// struct declarations\n')
    structDeclarations = structHandler.declareStructs()
    file.write(f'{structDeclarations}\n\n')

    file.write(f'// function declarations\n')
    functionDeclarations = functionHandler.declareFunctions()
    file.write(f'{functionDeclarations}\n\n')

# write wrappers for needed callbacks and API functions
def writeWrappers(file, callbackHandler, functionHandler):
    file.write(f'// callback wrappers\n')
    callbackCallers = callbackHandler.defineCallbacks()
    file.write(f'{callbackCallers}\n\n')

    file.write(f'// function wrappers\n')
    functionWrappers = functionHandler.defineWrappers()
    file.write(f'{functionWrappers}\n\n')

def main():
    parser = argparse.ArgumentParser(
        prog='binding-generator',
        description='Generates binding file based on C API AST dump.'
    )
    parser.add_argument('inputFile')
    parser.add_argument('cOutputFile')
    parser.add_argument('luaOutputFile')
    args = parser.parse_args()

    data = loadInfo(args.inputfile)

    structHandler = StructHandler(data)
    callbackHandler = CallbackHandler(data)
    functionHandler = FunctionHandler(data, structHandler)
    luaFunctionHandler = LuaFunctionHandler(functionHandler)

    with open(args.cOutputFile, 'w') as output:
        output.write('// Generated by binding-generator.py \n')
        writeHeaders(output)
        writeContext(output)
        writeDeclarations(output, structHandler, functionHandler)
        writeWrappers(output, callbackHandler, functionHandler)
        writeRegister(output, functionHandler)
        writeBoilerplate(output)

    with open(args.luaOutputFile, 'w') as luaOutput:
        writeLuaWrappers(luaOutput, luaFunctionHandler)

if __name__ == '__main__':
    main()