from lib.components import *
from lua_components import *
from lib.structs import StructHandler 
from lib.callbacks import CallbackHandler

import json
import argparse 
import boilerplate

HEADERS = [
    "lua.h",
    "lualib.h",
    "lauxlib.h"
]

def loadInfo(filename):
    with open(filename, 'r') as input:
        data = json.load(input)
    return data

def writeHeaders(file):
    for header in [Include(lib, True) for lib in HEADERS]:
        file.write(f'{header}\n') 
    file.write('\n')

def writeBoilerplate(file):
    file.write(boilerplate.code + '\n')

# writes wrapper into .lua binding file that is used to call API
# functions using struct pointers 
def writeLuaWrapper(luafile, module, fname, arglist, ptrname):
    seq = LuaSequence()
    seq = seq + LuaCallApi(module, fname, arglist)
    seq = seq + LuaCopyStruct('nstruct', ptrname)
    seq = seq + LuaReturn('value')
    wrapper = LuaFunction(
        f'{module}.{fname}',
        arglist,
        seq 
    )
    luafile.write(f'{wrapper}\n')

# write extern declarations of the targeted C API
def writeDeclarations(file, data):
    structDeclarations = structHandler.declareStructs()
    file.write(f'{structDeclarations}\n')

    for function in data:
        arglist = []
        for i, arg in enumerate(function["args"]):
            if arg["type"] == 'fptr_type':
                info = arg["info"]
                fptr = FunctionPointer(
                    info["return_expr"]["type_name"],
                    f'arg{i+1}',
                    [x["type_name"] for x in info["args"]]
                )
                arglist.append(str(fptr))
            elif arg['type'] == 'struct':
                arglist.append(f'struct {arg["type_name"]} arg{i+1}')
            else:
                arglist.append(f'{arg["type_name"]} arg{i+1}')

        declaration = Function(
            function["return_expr"]["type_name"],
            function["name"],
            arglist, 
            modifier=Modifier.EXTERN
        )

        file.write(f'{declaration}\n');
    file.write('\n');

    callbackCallers = callbackHandler.defineCallbacks()
    file.write(f'{callbackCallers}\n')

def writeContext(file):
    definition = Struct(
        'context',
        [Variable('lua_State*', 'stack'), Variable('int', 'idx')]
    )
    declaration = Variable('struct context', 'c')
    file.write(f'{definition}\n{declaration}\n\n')

# writes wrappers for API functions and required callback types to file
def writeWrappers(file, data):
    for function in data:
        content = Sequence()
        arglist = []
        for i, arg in enumerate(function["args"]):
            if arg["type"] == 'fptr_type':
                name = CallbackHandler.callbackWrapperName(arg["info"])
                arglist.append(f'&{name}')
                content = content + ContextChange(i+1);
            elif arg['type'] == 'struct':
                structName = arg['type_name']
                unpack = structHandler.unpackStruct(structName, i+1)
                arglist.append(f'arg{i+1}')
                content = content + unpack
            else:
                x = Variable(
                    "int",
                    f'arg{i+1}',
                    value=FunctionCall('lua_tonumber', ['L', i+1])
                )
                arglist.append(f'arg{i+1}')
                content = content + x

        apicall = FunctionCall(
            function["name"],
            arglist
        )

        content = content + FunctionCall('lua_pushinteger', ['L', apicall], semicolon=True) + Return(1)

        wrapper = Function(
            'int', 
            f'c_{function["name"]}', 
            ['lua_State* L'],
            seq=content
        )

        file.write(f'{wrapper}\n\n')

def writeRegister(file, data):
    xs = [f["name"] for f in data]
    register = LuaRegister("luareg", xs)
    file.write(f'{register}\n\n')

def main():
    parser = argparse.ArgumentParser(
        prog="binding-generator",
        description="Generates binding file based on C API AST dump."
    )
    parser.add_argument("inputfile")
    parser.add_argument("outputfile")
    args = parser.parse_args()

    data = loadInfo(args.inputfile)

    global structHandler, callbackHandler
    structHandler = StructHandler(data)
    callbackHandler = CallbackHandler(data)

    with open(args.outputfile, 'w') as output:
        output.write("// Generated by binding-generator.py \n")
        writeHeaders(output)
        writeContext(output)
        writeDeclarations(output, data)
        writeWrappers(output, data)
        writeRegister(output, data)
        output.write("// Boilerplate code \n")
        writeBoilerplate(output)

if __name__ == '__main__':
    main()