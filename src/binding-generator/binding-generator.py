from components import *
import json
import argparse 
import boilerplate

HEADERS = [
    "lua.h",
    "lualib.h",
    "lauxlib.h"
];

callbacks = {};

def load_info(filename):
    f = open(filename, 'r');
    data = json.load(f);
    f.close();
    return data;

def write_headers(file):
    for header in [Include(h, True) for h in HEADERS]:
        file.write(str(header) + '\n'); 
    file.write('\n');

def write_boilerplate(file):
    file.write(boilerplate.code + '\n');

def write_declarations(file, data):
    for function in data:
        arglist = []
        for i, arg in enumerate(function["args"]):
            if arg["type"] == 'fptr_type':
                fptr = FunctionPointer(
                    arg["info"]["return_expr"]["type_name"],
                    f'arg{i+1}',
                    [x["type_name"] for x in arg["info"]["args"]]
                );
                arglist = arglist + [str(fptr)];
            else:
                arglist = arglist + [f'{arg["type_name"]} arg{i+1}']

        f = Function(
            function["return_expr"]["type_name"],
            function["name"],
            arglist, 
            modifier=Modifier.EXTERN
        );

        file.write(str(f) + '\n');
    file.write('\n');

def write_context(file):
    context = Struct(
        'context',
        [Variable('lua_State*', 'stack'),
         Variable('int', 'idx')]
    );
    file.write(str(context) + '\n\n');
    
    declaration = Variable('struct context', 'c');
    file.write(str(declaration) + '\n\n');

def callback_name(info):
    args = ''.join([arg["type_name"] for arg in info["args"]]);
    return f'{info["return_expr"]["type_name"]}_{args}';

def callback_wrapper(info, name):
    args = [f'{arg["type_name"]} arg{i+1}' for i, arg in enumerate(info["args"])];
    content = Block([FunctionCall('lua_pushvalue', ['c.stack', 'c.idx'], semicolon=True)]);
    for i in range(len(args)):
        f = FunctionCall('lua_pushinteger', ['c.stack', f'arg{i+1}'], semicolon=True);
        content = content + f;
    pcall = FunctionCall('lua_pcall', ['c.stack', len(args), 1, 0], semicolon=True);
    pop = FunctionCall('lua_tonumber', ['c.stack', -1])
    content = content + pcall + Return(pop);
    return Function(info["return_expr"]["type_name"], name, args, content=content);

def write_wrappers(file, data):
    for function in data:
        argcount = len(function["args"]);

        setup = [];
        apiargs = [];
        for i, arg in enumerate(function["args"]):
            if arg["type"] == 'fptr_type':
                name = callback_name(arg["info"]);
                if name not in callbacks:
                    callbacks[name] = True;
                    wrapper = callback_wrapper(arg["info"], name);
                    file.write(str(wrapper) + '\n\n');
                apiargs = apiargs + [f'&{name}'];
                setup = setup + [ContextChange(i+1)];
            else:
                x = Variable(
                    "int",
                    f'arg{i+1}',
                    array=False,
                    value=FunctionCall('lua_tonumber', ['L', i+1])
                );
                apiargs = apiargs + [f'arg{i+1}']
                setup = setup + [x];
        prefix = Block(setup);

        apicall = FunctionCall(
            function["name"],
            apiargs
        );

        if function['return_expr']['type_name'] == 'int':
            suffix = Block([
                FunctionCall('lua_pushinteger', ['L', apicall], semicolon=True),
                Return(1)
            ]); 
        else:
            apicall.semicolon = True;
            suffix = Block([
                apicall,
                Return(0)
            ]); 

        wrapper = Function(
            "int", 
            f'c_{function["name"]}', 
            ["lua_State* L"],
            content=prefix + suffix
        );

        file.write(str(wrapper) + '\n\n'); 

def write_register(file, data):
    xs = ['{' + f'"{fun["name"]}", c_{fun["name"]}' + '}' for fun in data];

    register = LuaRegister("luareg", xs);
    file.write(str(register) + '\n');

def main():
    parser = argparse.ArgumentParser(
        prog="binding-generator",
        description="Generates binding file based on C API AST dump."
    );
    parser.add_argument("inputfile");
    parser.add_argument("outputfile");
    args = parser.parse_args();

    data = load_info(args.inputfile);
    with open(args.outputfile, 'w') as output:
        output.write("// Generated by binding-generator.py \n");
        write_headers(output);
        write_context(output);
        write_declarations(output, data);
        write_wrappers(output, data);
        write_register(output, data);
        output.write("\n// Boilerplate code \n");
        write_boilerplate(output);

if __name__ == '__main__':
    main();